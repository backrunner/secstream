<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecStream - Secure Audio Streaming Demo</title>
    <script type="importmap">
    {
        "imports": {
            "fflate": "https://unpkg.com/fflate@0.8.2/esm/browser.js"
        }
    }
    </script>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1 class="logo">SecStream</h1>
            <p class="subtitle">Secure Real-time Audio Streaming</p>
            <span class="version">v0.1.1 - Production Demo</span>
        </div>

        <!-- Server Configuration -->
        <div class="card">
            <h3 class="section-title">‚öôÔ∏è Server Configuration</h3>
            <div style="padding: 15px;">
                <label style="display: flex; align-items: center; cursor: pointer; user-select: none;">
                    <input type="checkbox" id="randomizeSliceLength" style="margin-right: 10px; width: 18px; height: 18px; cursor: pointer;">
                    <div>
                        <div style="font-weight: 500; margin-bottom: 4px;">
                            Enable Randomized Slice Lengths
                        </div>
                        <div style="font-size: 0.85em; color: #888; line-height: 1.4;">
                            Enables variable-length slices (¬±40% variance) for enhanced security against traffic analysis.
                            Each session gets a unique randomization pattern.
                        </div>
                    </div>
                </label>
            </div>
        </div>

        <!-- Upload Section -->
        <div class="card">
            <div class="upload-area" id="uploadArea">
                <span class="upload-icon">üéµ</span>
                <div class="upload-text">Drag & drop your audio file here</div>
                <div class="upload-hint">or click to browse (WAV, MP3, OGG, M4A supported)</div>
                <input type="file" id="audioFile" accept="audio/*" style="display: none;">
            </div>
        </div>

        <!-- Loading -->
        <div class="loading hidden" id="loading">
            <div class="spinner"></div>
            <p>Processing audio file...</p>
        </div>

        <!-- Status Messages -->
        <div id="status"></div>

        <!-- Session Information -->
        <div class="card hidden" id="sessionInfo">
            <h3 class="section-title">
                üîê Session Information
            </h3>
            <div class="session-grid" id="sessionGrid">
                <!-- Dynamic session info will be inserted here -->
            </div>
        </div>

        <!-- Audio Player -->
        <div class="card hidden" id="player">
            <h3 class="section-title">
                üéÆ Secure Audio Player
            </h3>

            <div class="player">
                <div class="controls">
                    <button class="play-btn" id="playBtn">
                        <svg class="play-icon" viewBox="0 0 24 24" width="30" height="30">
                            <path fill="currentColor" d="M8 5v14l11-7z"/>
                        </svg>
                        <svg class="pause-icon" viewBox="0 0 24 24" width="30" height="30">
                            <path fill="currentColor" d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                        </svg>
                    </button>
                    <div class="time-display">
                        <span id="currentTime">0:00</span> / <span id="totalTime">0:00</span>
                    </div>
                </div>

                <div class="progress-container" id="progressBar">
                    <div class="progress-fill" style="width: 0%"></div>
                </div>

                <!-- Strategy Selection -->
                <div class="strategy-section">
                    <h4 class="section-title">
                        ‚öôÔ∏è Streaming Strategy
                    </h4>
                    <div class="strategy-grid">
                        <div class="strategy-group">
                            <label for="bufferStrategy">Buffer Strategy</label>
                            <select id="bufferStrategy">
                                <option value="balanced">Balanced (Recommended)</option>
                                <option value="conservative">Conservative</option>
                                <option value="aggressive">Aggressive</option>
                            </select>
                        </div>
                        <div class="strategy-group">
                            <label for="prefetchStrategy">Prefetch Strategy</label>
                            <select id="prefetchStrategy">
                                <option value="linear">Linear (Default)</option>
                                <option value="adaptive">Adaptive</option>
                                <option value="none">None</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Real-time Stats -->
                <div class="strategy-section">
                    <h4 class="section-title">
                        üìä Real-time Statistics
                    </h4>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <span class="stat-value" id="bufferSize">0</span>
                            <span class="stat-label">Buffered Slices</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="totalSlices">0</span>
                            <span class="stat-label">Total Slices</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="currentStrategy">balanced/linear</span>
                            <span class="stat-label">Active Strategy</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="networkRequests">0</span>
                            <span class="stat-label">Network Requests</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Import the actual SecStream library components with CORRECT paths
        let SecureAudioClient, SecureAudioPlayer, DemoTransport;
        let ConservativeBufferStrategy, AggressiveBufferStrategy, BalancedBufferStrategy;
        let LinearPrefetchStrategy, AdaptivePrefetchStrategy, NoPrefetchStrategy;
        let isSecStreamAvailable = false;

        try {
            // FIXED: Use server-served paths instead of relative file paths
            const clientModule = await import('/dist/client/index.js');
            const transportModule = await import('/dist/demo-transport.js');

            SecureAudioClient = clientModule.SecureAudioClient;
            SecureAudioPlayer = clientModule.SecureAudioPlayer;
            ConservativeBufferStrategy = clientModule.ConservativeBufferStrategy;
            AggressiveBufferStrategy = clientModule.AggressiveBufferStrategy;
            BalancedBufferStrategy = clientModule.BalancedBufferStrategy;
            LinearPrefetchStrategy = clientModule.LinearPrefetchStrategy;
            AdaptivePrefetchStrategy = clientModule.AdaptivePrefetchStrategy;
            NoPrefetchStrategy = clientModule.NoPrefetchStrategy;

            DemoTransport = transportModule.DemoTransport;
            isSecStreamAvailable = true;

            console.log('‚úÖ SecStream library loaded successfully');
            showStatus('success', 'üîí SecStream library loaded - Real secure streaming available!');
        } catch (error) {
            console.warn('‚ö†Ô∏è SecStream library not available, falling back to Web Audio demo');
            console.error('Import error details:', error);
            showStatus('warning', '‚ö†Ô∏è SecStream library not available - Using Web Audio fallback demo');
        }

        // Initialize variables
        let audioContext = null;
        let secureClient = null;
        let securePlayer = null;
        let currentSession = null;
        let currentAudio = null;
        let isPlaying = false;
        let progressInterval = null;
        let bufferStatsInterval = null;
        let networkRequestCount = 0;
        let currentSeekOperationId = 0; // Track current seek operation ID

        // Track network requests by wrapping fetch calls
        const originalFetch = window.fetch;
        window.fetch = function(...args) {
            networkRequestCount++;
            networkRequestsEl.textContent = networkRequestCount;
            return originalFetch.apply(this, args);
        };

        // DOM elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('audioFile');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');
        const sessionInfo = document.getElementById('sessionInfo');
        const sessionGrid = document.getElementById('sessionGrid');
        const player = document.getElementById('player');
        const playBtn = document.getElementById('playBtn');
        const progressBar = document.getElementById('progressBar');
        const progressFill = progressBar.querySelector('.progress-fill');
        const currentTime = document.getElementById('currentTime');
        const totalTime = document.getElementById('totalTime');

        // Stats elements
        const bufferSizeEl = document.getElementById('bufferSize');
        const totalSlicesEl = document.getElementById('totalSlices');
        const currentStrategyEl = document.getElementById('currentStrategy');
        const networkRequestsEl = document.getElementById('networkRequests');

        // File upload handling
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Strategy change handlers
        document.getElementById('bufferStrategy').addEventListener('change', updateStrategy);
        document.getElementById('prefetchStrategy').addEventListener('change', updateStrategy);

        function showStatus(type, message) {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;

            // Auto-hide success messages after 5 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.innerHTML = '';
                }, 5000);
            }
        }

        function showLoading(show = true) {
            loading.classList.toggle('hidden', !show);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function setPlayButtonState(isPlaying) {
            if (isPlaying) {
                playBtn.classList.add('playing');
            } else {
                playBtn.classList.remove('playing');
            }
        }

        async function handleFile(file) {
            showLoading(true);
            showStatus('info', `üìÅ Processing ${file.name}...`);

            try {
                if (isSecStreamAvailable) {
                    await handleSecStreamUpload(file);
                } else {
                    await handleWebAudioUpload(file);
                }
            } catch (error) {
                console.error('File handling error:', error);
                showStatus('error', `‚ùå Error processing file: ${error.message}`);
            } finally {
                showLoading(false);
            }
        }

        async function handleSecStreamUpload(file) {
            try {
                console.log('üîê Starting SecStream upload process...');
                console.log('üìÅ File details:', {
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    lastModified: file.lastModified
                });

                // Get randomize slice length setting from checkbox
                const randomizeSliceLength = document.getElementById('randomizeSliceLength').checked;
                console.log('‚öôÔ∏è Randomize slice length:', randomizeSliceLength);

                // Create transport instance with configuration
                const transport = new DemoTransport('http://localhost:3000', randomizeSliceLength);
                console.log('üöÄ Created DemoTransport instance with randomizeSliceLength:', randomizeSliceLength);

                // Create secure client
                secureClient = new SecureAudioClient(transport, {
                    retryConfig: {
                        maxRetries: 3,
                        retryDelay: 1000,
                    }
                });
                console.log('üîß Created SecureAudioClient with config:', {
                    maxRetries: 3,
                    retryDelay: 1000
                });

                showStatus('info', 'üîê Creating secure session...');

                // Create session with the audio file
                console.log('üì§ Attempting to create session...');
                try {
                    const sessionId = await secureClient.createSession(file);
                    console.log('‚úÖ Session created successfully:', sessionId);
                    currentSession = { sessionId };
                } catch (sessionError) {
                    console.error('‚ùå Session creation failed with error:', sessionError);
                    console.error('‚ùå Error details:', {
                        message: sessionError.message,
                        stack: sessionError.stack,
                        name: sessionError.name,
                        cause: sessionError.cause
                    });
                    throw sessionError;
                }

                showStatus('info', 'üîë Performing key exchange...');

                // Perform key exchange and initialize session
                console.log('üîë Attempting key exchange and session initialization...');
                try {
                    const sessionData = await secureClient.initializeSession(currentSession.sessionId);
                    console.log('‚úÖ Session initialized successfully:', sessionData);
                    currentSession.sessionInfo = sessionData;
                } catch (initError) {
                    console.error('‚ùå Session initialization failed:', initError);
                    console.error('‚ùå Init error details:', {
                        message: initError.message,
                        stack: initError.stack
                    });
                    throw initError;
                }

                // Display session information
                displaySessionInfo(currentSession.sessionInfo, true);

                // Create secure player with client and selected strategies
                const { bufferStrategy, prefetchStrategy } = getSelectedStrategies();
                securePlayer = new SecureAudioPlayer(secureClient, {
                    bufferStrategy: bufferStrategy,
                    prefetchStrategy: prefetchStrategy
                });
                console.log('üéµ SecureAudioPlayer created successfully');
                console.log('üìä Using strategies:', { bufferStrategy: bufferStrategy.constructor.name, prefetchStrategy: prefetchStrategy.constructor.name });

                setupSecStreamPlayer();
                player.classList.remove('hidden');

                showStatus('success', '‚úÖ SecStream session ready! Real secure streaming active.');
                console.log('üîí SecStream session setup complete:', currentSession.sessionInfo);

            } catch (error) {
                console.error('üí• SecStream upload process failed:', error);
                console.error('üí• Full error stack:', error.stack);

                // Check if it's a network-related error
                if (error.message?.includes('fetch')) {
                    console.error('üåê Network error detected - checking server connectivity...');
                    try {
                        const response = await fetch('http://localhost:3000/health');
                        console.log('üè• Server health check:', response.status, response.statusText);
                    } catch (healthError) {
                        console.error('üö® Server appears to be down:', healthError);
                    }
                }

                throw new Error(`SecStream session creation failed: ${error.message}`);
            }
        }

        async function handleWebAudioUpload(file) {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                // Simulate session info
                const sessionData = {
                    sessionId: `web-audio-${Date.now()}`,
                    format: 'Web Audio',
                    sampleRate: audioBuffer.sampleRate,
                    channels: audioBuffer.numberOfChannels,
                    duration: audioBuffer.duration,
                    totalSlices: Math.ceil(audioBuffer.duration / 5), // 5 second slices
                    sliceDuration: 5000,
                };

                currentSession = { sessionInfo: sessionData };
                currentAudio = audioBuffer;

                displaySessionInfo(sessionData, false);
                setupWebAudioPlayer();
                player.classList.remove('hidden');

                showStatus('success', '‚úÖ Web Audio loaded! (Fallback mode - no encryption)');

            } catch (error) {
                throw new Error(`Web Audio decoding failed: ${error.message}`);
            }
        }

        function displaySessionInfo(sessionData, isSecStream) {
            const items = [
                { label: 'Session ID', value: sessionData.sessionId || 'N/A' },
                { label: 'Format', value: sessionData.format || 'Unknown' },
                { label: 'Sample Rate', value: sessionData.sampleRate ? `${sessionData.sampleRate} Hz` : 'Unknown' },
                { label: 'Channels', value: sessionData.channels || 'Unknown' },
                { label: 'Duration', value: sessionData.duration ? formatTime(sessionData.duration) : 'Unknown' },
                { label: 'Total Slices', value: sessionData.totalSlices || 'Unknown' },
                { label: 'Encryption', value: isSecStream ? 'üîí AES-256-GCM' : '‚ùå None (Fallback)' },
                { label: 'Transport', value: isSecStream ? 'üåê HTTP/SecStream' : 'üíæ Memory (Local)' }
            ];

            sessionGrid.innerHTML = items.map(item => `
                <div class="info-item">
                    <div class="info-label">${item.label}</div>
                    <div class="info-value">${item.value}</div>
                </div>
            `).join('');

            // Update total slices display
            totalSlicesEl.textContent = sessionData.totalSlices || 0;

            sessionInfo.classList.remove('hidden');
        }

        function getSelectedStrategies() {
            const bufferStrategyName = document.getElementById('bufferStrategy').value;
            const prefetchStrategyName = document.getElementById('prefetchStrategy').value;

            let bufferStrategy, prefetchStrategy;

            if (isSecStreamAvailable) {
                switch (bufferStrategyName) {
                    case 'conservative':
                        bufferStrategy = new ConservativeBufferStrategy();
                        break;
                    case 'aggressive':
                        bufferStrategy = new AggressiveBufferStrategy();
                        break;
                    case 'balanced':
                    default:
                        bufferStrategy = new BalancedBufferStrategy();
                        break;
                }

                switch (prefetchStrategyName) {
                    case 'adaptive':
                        prefetchStrategy = new AdaptivePrefetchStrategy();
                        break;
                    case 'none':
                        prefetchStrategy = new NoPrefetchStrategy();
                        break;
                    case 'linear':
                    default:
                        prefetchStrategy = new LinearPrefetchStrategy();
                        break;
                }
            }

            // Update strategy display
            currentStrategyEl.textContent = `${bufferStrategyName}/${prefetchStrategyName}`;

            return { bufferStrategy, prefetchStrategy };
        }

        function updateStrategy() {
            if (secureClient && securePlayer && isSecStreamAvailable) {
                // Get selected strategies
                const { bufferStrategy, prefetchStrategy } = getSelectedStrategies();

                // Remember playback state
                const wasPlaying = securePlayer.isPlaying;
                const currentTime = securePlayer.currentTime;

                // Destroy old player
                securePlayer.destroy();

                // Create new player with updated strategies
                securePlayer = new SecureAudioPlayer(secureClient, {
                    bufferStrategy: bufferStrategy,
                    prefetchStrategy: prefetchStrategy
                });

                // Setup event listeners again
                setupSecStreamPlayer();

                // Restore playback state
                if (currentTime > 0) {
                    securePlayer.seekToTime(currentTime, wasPlaying).catch(err => {
                        console.error('Failed to restore playback after strategy change:', err);
                    });
                }

                showStatus('success', `‚úÖ Strategies updated: ${bufferStrategy.constructor.name} / ${prefetchStrategy.constructor.name}`);
                console.log('üìä Strategies updated:', { bufferStrategy: bufferStrategy.constructor.name, prefetchStrategy: prefetchStrategy.constructor.name });
            } else {
                getSelectedStrategies(); // Update display even in fallback mode
            }
        }

        function setupSecStreamPlayer() {
            if (!securePlayer) return;

            setPlayButtonState(false);
            playBtn.onclick = toggleSecStreamPlay;

            // Set total time
            if (currentSession?.sessionInfo) {
                const duration = currentSession.sessionInfo.totalSlices * currentSession.sessionInfo.sliceDuration / 1000;
                totalTime.textContent = formatTime(duration);
            }

            // Set up player events
            securePlayer.addEventListener('play', () => {
                console.log('[Player] Play event - Starting playback');
                setPlayButtonState(true);
                startBufferStatsUpdates();
            });

            securePlayer.addEventListener('pause', () => {
                console.log('[Player] Pause event - Playback paused');
                setPlayButtonState(false);
                stopBufferStatsUpdates(); // Stop buffer updates when paused
            });

            securePlayer.addEventListener('ended', () => {
                console.log('[Player] Ended event - Playback completed');
                setPlayButtonState(false);

                // Update progress bar to 100% completion before stopping updates
                progressFill.style.width = '100%';
                if (currentSession?.sessionInfo) {
                    const totalDuration = currentSession.sessionInfo.totalSlices * currentSession.sessionInfo.sliceDuration / 1000;
                    currentTime.textContent = formatTime(totalDuration);
                }

                stopBufferStatsUpdates();
            });

            // Progress bar seeking with drag support
            let isDragging = false;
            let dragPercent = 0;

            // Handle realtime timeupdate events (replaces setInterval)
            securePlayer.addEventListener('timeupdate', (e) => {
                // Skip updating progress if user is dragging
                if (isDragging) {
                    return;
                }

                const { currentTime: seconds, duration, progress } = e.detail;
                const percent = Math.min(progress * 100, 100);
                progressFill.style.width = `${percent}%`;
                currentTime.textContent = formatTime(seconds);

                // Note: Prefetching is now handled automatically by the PrefetchStrategy
                // No manual prefetch calls needed here
            });

            // Handle retry events for slice loading
            securePlayer.addEventListener('loadretry', (e) => {
                const { slice, attempt, maxRetries, error } = e.detail;
                showStatus('warning', `üîÑ Retrying slice ${slice} (${attempt}/${maxRetries}): ${error}`);
                console.log(`üîÑ SecStream: Retrying slice ${slice}, attempt ${attempt}/${maxRetries}`);
            });

            // Handle seek events
            securePlayer.addEventListener('seek', (e) => {
                const { time, slice, offset } = e.detail;
                console.log(`üéØ SecStream: Seeked to ${time.toFixed(2)}s (slice ${slice}, offset ${offset.toFixed(2)}s)`);
            });

            securePlayer.addEventListener('error', (event) => {
                const { message, retryable, time } = event.detail || {};
                console.error('[Player] Error event:', { message, retryable, time });

                if (retryable && time !== undefined) {
                    showStatus('error', `‚ùå ${message} - Click progress bar to retry from ${formatTime(time)}`);
                } else {
                    showStatus('error', `‚ùå Playback error: ${message || 'Unknown error'}`);
                }
                console.error('üö® SecStream error:', event.detail);
            });

            // Handle AudioContext suspension (browser autoplay policy)
            securePlayer.addEventListener('suspended', (event) => {
                const { message, state } = event.detail || {};
                console.warn('[Player] Suspended event - AudioContext blocked by browser autoplay policy:', { message, state });

                // Show user-friendly message
                showStatus('warning', 'üîá Audio blocked by browser - Click the play button to enable audio playback');

                // Ensure play button shows play state (not playing)
                setPlayButtonState(false);
            });

            // Drag seeking helper functions
            const updateProgressVisually = (e) => {
                if (!currentSession) return;

                const rect = progressBar.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const percent = Math.max(0, Math.min(1, clickX / rect.width));

                // Calculate target time for display
                const totalDuration = currentSession.sessionInfo.totalSlices * currentSession.sessionInfo.sliceDuration / 1000;
                const targetTime = percent * totalDuration;

                // Update UI immediately
                progressFill.style.width = `${percent * 100}%`;
                currentTime.textContent = formatTime(targetTime);

                return { percent, targetTime };
            };

            const performSeek = async (percent, targetTime) => {
                if (!securePlayer || !currentSession) return;

                // Generate unique operation ID for this seek
                const operationId = ++currentSeekOperationId;

                // Remember if we were playing before seeking
                const wasPlaying = securePlayer.isPlaying;

                // Use the new time-based seeking
                try {
                    if (currentSeekOperationId !== operationId) return;

                    console.log(`[Seek] Seeking to ${targetTime.toFixed(2)}s (${(percent * 100).toFixed(1)}%)`);
                    await securePlayer.seekToTime(targetTime, wasPlaying);

                    if (currentSeekOperationId !== operationId) return;
                    console.log(`[Seek] Seek completed to ${targetTime.toFixed(2)}s`);
                } catch (seekError) {
                    if (currentSeekOperationId === operationId) {
                        console.error('[Seek] Seek failed:', seekError);
                    }
                }
            };

            // Mouse drag handlers
            progressBar.addEventListener('mousedown', (e) => {
                isDragging = true;
                const result = updateProgressVisually(e);
                if (result) {
                    dragPercent = result.percent;
                }
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const result = updateProgressVisually(e);
                    if (result) {
                        dragPercent = result.percent;
                    }
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (isDragging) {
                    isDragging = false;
                    // Perform the actual seek on mouse up
                    const result = updateProgressVisually(e);
                    if (result) {
                        performSeek(result.percent, result.targetTime);
                    }
                }
            });

            // Click handler for single clicks (no drag)
            progressBar.addEventListener('click', (e) => {
                const result = updateProgressVisually(e);
                if (result) {
                    performSeek(result.percent, result.targetTime);
                }
            });
        }

        function setupWebAudioPlayer() {
            if (!currentAudio) return;

            setPlayButtonState(false);
            playBtn.onclick = toggleWebAudioPlay;
            totalTime.textContent = formatTime(currentAudio.duration);

            // Set fallback stats for Web Audio mode
            bufferSizeEl.textContent = 'N/A';
            networkRequestsEl.textContent = '0';
            currentStrategyEl.textContent = 'web-audio/local';

            // Progress bar seeking
            progressBar.onclick = (e) => {
                if (!currentAudio) return;

                const rect = progressBar.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const percent = clickX / rect.width;
                const targetTime = percent * currentAudio.duration;

                // In real implementation, would seek to targetTime
                console.log(`Would seek to ${formatTime(targetTime)} (Web Audio fallback)`);
            };
        }

        async function toggleSecStreamPlay() {
            if (!securePlayer) return;

            try {
                if (securePlayer.isPlaying) {
                    securePlayer.pause(); // pause() is synchronous, no await needed
                } else {
                    // Check if we're resuming from pause or starting fresh
                    const currentSlice = securePlayer.currentSlice;
                    const sessionInfo = currentSession?.sessionInfo;

                    if (!sessionInfo) {
                        throw new Error('No session information available');
                    }

                    // Only preload current slice if not available
                    // Prefetching of subsequent slices is handled by PrefetchStrategy
                    if (!secureClient.isSliceAvailable(currentSlice)) {
                        try {
                            // Load current slice only
                            const sliceId = sessionInfo.sliceIds[currentSlice];
                            if (sliceId) {
                                await secureClient.loadSlice(sliceId);
                            }
                            console.log('‚úÖ Audio slice loaded successfully');
                        } catch (loadError) {
                            console.warn('‚ö†Ô∏è Slice load failed:', loadError);
                        }
                    }

                    await securePlayer.play();
                }
            } catch (error) {
                showStatus('error', `‚ùå Playback control error: ${error.message}`);
                console.error('Playback control error details:', error);

                // Reset button state on error
                setPlayButtonState(false);
            }
        }

        async function toggleWebAudioPlay() {
            // Web Audio fallback implementation
            if (isPlaying) {
                setPlayButtonState(false);
                isPlaying = false;
                stopProgressUpdates();
            } else {
                setPlayButtonState(true);
                isPlaying = true;
                startProgressUpdates();
            }
        }

        function startProgressUpdates() {
            if (progressInterval) clearInterval(progressInterval);

            progressInterval = setInterval(() => {
                if (securePlayer && isSecStreamAvailable) {
                    // Only update progress if actually playing
                    if (!securePlayer.isPlaying) {
                        return; // Don't update progress when paused
                    }

                    // Get real progress from SecStream player using time-based calculation
                    const currentSeconds = securePlayer.currentTime;
                    const totalSlices = currentSession?.sessionInfo?.totalSlices || 1;
                    const totalDuration = totalSlices * (currentSession?.sessionInfo?.sliceDuration || 5000) / 1000;

                    // Use time-based progress for more accurate representation
                    const percent = Math.min((currentSeconds / totalDuration) * 100, 100);

                    progressFill.style.width = `${percent}%`;
                    currentTime.textContent = formatTime(currentSeconds);
                } else if (currentAudio) {
                    // Simulate progress for Web Audio fallback only if local isPlaying is true
                    if (!isPlaying) {
                        return;
                    }

                    const currentSeconds = parseFloat(currentTime.textContent.split(':').reduce((acc, time) => (60 * acc) + +time, 0));
                    const newSeconds = Math.min(currentSeconds + 0.1, currentAudio.duration);
                    const percent = (newSeconds / currentAudio.duration) * 100;

                    progressFill.style.width = `${percent}%`;
                    currentTime.textContent = formatTime(newSeconds);

                    if (newSeconds >= currentAudio.duration) {
                        setPlayButtonState(false);
                        isPlaying = false;
                        stopProgressUpdates();
                    }
                }
            }, 100);
        }

        function stopProgressUpdates() {
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
        }

        function startBufferStatsUpdates() {
            if (bufferStatsInterval) clearInterval(bufferStatsInterval);

            if (securePlayer && isSecStreamAvailable) {
                bufferStatsInterval = setInterval(() => {
                    try {
                        // Get buffer stats from player
                        const stats = securePlayer.getBufferStats();

                        // Update buffer size (number of loaded slices)
                        const bufferSize = stats && typeof stats.bufferSize === 'number' ? stats.bufferSize : 0;
                        bufferSizeEl.textContent = `${bufferSize} slices`;

                        // Also update current slice information for better debugging
                        console.debug('Buffer stats:', {
                            bufferSize,
                            currentSlice: securePlayer.currentSlice,
                            isPlaying: securePlayer.isPlaying,
                            currentTime: securePlayer.currentTime
                        });
                    } catch (error) {
                        console.warn('Error getting buffer stats:', error);
                        // Fallback to showing 0 if there's an error
                        bufferSizeEl.textContent = '0 slices';
                    }
                }, 1000);
            } else {
                // In fallback mode, show N/A
                bufferSizeEl.textContent = 'N/A';
            }
        }

        function stopBufferStatsUpdates() {
            if (bufferStatsInterval) {
                clearInterval(bufferStatsInterval);
                bufferStatsInterval = null;
            }
        }

        // Initialize the application
        console.log('üöÄ SecStream Demo initialized');

        if (isSecStreamAvailable) {
            console.log('üîí Real SecStream functionality available');
        } else {
            console.log('üí° Running in Web Audio fallback mode');
        }
    </script>
</body>

</html>