<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecStream - Secure Audio Streaming Demo</title>
    <script type="importmap">
    {
        "imports": {
            "fflate": "https://unpkg.com/fflate@0.8.2/esm/browser.js"
        }
    }
    </script>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1 class="logo">SecStream</h1>
            <p class="subtitle">Secure Real-time Audio Streaming</p>
            <span class="version">v0.1.0 - Production Demo</span>
        </div>

        <!-- Upload Section -->
        <div class="card">
            <div class="upload-area" id="uploadArea">
                <span class="upload-icon">üéµ</span>
                <div class="upload-text">Drag & drop your audio file here</div>
                <div class="upload-hint">or click to browse (WAV, MP3, OGG, M4A supported)</div>
                <input type="file" id="audioFile" accept="audio/*" style="display: none;">
            </div>
        </div>

        <!-- Loading -->
        <div class="loading hidden" id="loading">
            <div class="spinner"></div>
            <p>Processing audio file...</p>
        </div>

        <!-- Status Messages -->
        <div id="status"></div>

        <!-- Session Information -->
        <div class="card hidden" id="sessionInfo">
            <h3 class="section-title">
                üîê Session Information
            </h3>
            <div class="session-grid" id="sessionGrid">
                <!-- Dynamic session info will be inserted here -->
            </div>
        </div>

        <!-- Audio Player -->
        <div class="card hidden" id="player">
            <h3 class="section-title">
                üéÆ Secure Audio Player
            </h3>

            <div class="player">
                <div class="controls">
                    <button class="play-btn" id="playBtn"></button>
                    <div class="time-display">
                        <span id="currentTime">0:00</span> / <span id="totalTime">0:00</span>
                    </div>
                </div>

                <div class="progress-container" id="progressBar">
                    <div class="progress-fill" style="width: 0%"></div>
                </div>

                <!-- Strategy Selection -->
                <div class="strategy-section">
                    <h4 class="section-title">
                        ‚öôÔ∏è Streaming Strategy
                    </h4>
                    <div class="strategy-grid">
                        <div class="strategy-group">
                            <label for="bufferStrategy">Buffer Strategy</label>
                            <select id="bufferStrategy">
                                <option value="balanced">Balanced (Recommended)</option>
                                <option value="conservative">Conservative</option>
                                <option value="aggressive">Aggressive</option>
                            </select>
                        </div>
                        <div class="strategy-group">
                            <label for="prefetchStrategy">Prefetch Strategy</label>
                            <select id="prefetchStrategy">
                                <option value="linear">Linear (Default)</option>
                                <option value="adaptive">Adaptive</option>
                                <option value="none">None</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Real-time Stats -->
                <div class="strategy-section">
                    <h4 class="section-title">
                        üìä Real-time Statistics
                    </h4>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <span class="stat-value" id="bufferSize">0</span>
                            <span class="stat-label">Buffer Size</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="totalSlices">0</span>
                            <span class="stat-label">Total Slices</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="currentStrategy">balanced/linear</span>
                            <span class="stat-label">Active Strategy</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="networkRequests">0</span>
                            <span class="stat-label">Network Requests</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Import the actual SecStream library components with CORRECT paths
        let SecureAudioClient, SecureAudioPlayer, DemoTransport;
        let ConservativeBufferStrategy, AggressiveBufferStrategy, BalancedBufferStrategy;
        let LinearPrefetchStrategy, AdaptivePrefetchStrategy, NoPrefetchStrategy;
        let isSecStreamAvailable = false;

        try {
            // FIXED: Use server-served paths instead of relative file paths
            const clientModule = await import('/dist/client/index.js');
            const transportModule = await import('/dist/demo-transport.js');

            SecureAudioClient = clientModule.SecureAudioClient;
            SecureAudioPlayer = clientModule.SecureAudioPlayer;
            ConservativeBufferStrategy = clientModule.ConservativeBufferStrategy;
            AggressiveBufferStrategy = clientModule.AggressiveBufferStrategy;
            BalancedBufferStrategy = clientModule.BalancedBufferStrategy;
            LinearPrefetchStrategy = clientModule.LinearPrefetchStrategy;
            AdaptivePrefetchStrategy = clientModule.AdaptivePrefetchStrategy;
            NoPrefetchStrategy = clientModule.NoPrefetchStrategy;

            DemoTransport = transportModule.DemoTransport;
            isSecStreamAvailable = true;

            console.log('‚úÖ SecStream library loaded successfully');
            showStatus('success', 'üîí SecStream library loaded - Real secure streaming available!');
        } catch (error) {
            console.warn('‚ö†Ô∏è SecStream library not available, falling back to Web Audio demo');
            console.error('Import error details:', error);
            showStatus('warning', '‚ö†Ô∏è SecStream library not available - Using Web Audio fallback demo');
        }

        // Initialize variables
        let audioContext = null;
        let secureClient = null;
        let securePlayer = null;
        let currentSession = null;
        let currentAudio = null;
        let isPlaying = false;
        let progressInterval = null;
        let bufferStatsInterval = null;
        let networkRequestCount = 0;

        // DOM elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('audioFile');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');
        const sessionInfo = document.getElementById('sessionInfo');
        const sessionGrid = document.getElementById('sessionGrid');
        const player = document.getElementById('player');
        const playBtn = document.getElementById('playBtn');
        const progressBar = document.getElementById('progressBar');
        const progressFill = progressBar.querySelector('.progress-fill');
        const currentTime = document.getElementById('currentTime');
        const totalTime = document.getElementById('totalTime');

        // Stats elements
        const bufferSizeEl = document.getElementById('bufferSize');
        const totalSlicesEl = document.getElementById('totalSlices');
        const currentStrategyEl = document.getElementById('currentStrategy');
        const networkRequestsEl = document.getElementById('networkRequests');

        // File upload handling
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Strategy change handlers
        document.getElementById('bufferStrategy').addEventListener('change', updateStrategy);
        document.getElementById('prefetchStrategy').addEventListener('change', updateStrategy);

        function showStatus(type, message) {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;

            // Auto-hide success messages after 5 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.innerHTML = '';
                }, 5000);
            }
        }

        function showLoading(show = true) {
            loading.classList.toggle('hidden', !show);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updateNetworkRequestCount() {
            networkRequestCount++;
            networkRequestsEl.textContent = networkRequestCount;
        }

        async function handleFile(file) {
            showLoading(true);
            showStatus('info', `üìÅ Processing ${file.name}...`);

            try {
                if (isSecStreamAvailable) {
                    await handleSecStreamUpload(file);
                } else {
                    await handleWebAudioUpload(file);
                }
            } catch (error) {
                console.error('File handling error:', error);
                showStatus('error', `‚ùå Error processing file: ${error.message}`);
            } finally {
                showLoading(false);
            }
        }

        async function handleSecStreamUpload(file) {
            try {
                console.log('üîê Starting SecStream upload process...');
                console.log('üìÅ File details:', {
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    lastModified: file.lastModified
                });

                // Create transport instance
                const transport = new DemoTransport('http://localhost:3000');
                console.log('üöÄ Created DemoTransport instance');

                // Create secure client
                secureClient = new SecureAudioClient(transport, {
                    retryConfig: {
                        maxRetries: 3,
                        retryDelay: 1000,
                    }
                });
                console.log('üîß Created SecureAudioClient with config:', {
                    maxRetries: 3,
                    retryDelay: 1000
                });

                showStatus('info', 'üîê Creating secure session...');
                updateNetworkRequestCount();

                // Create session with the audio file
                console.log('üì§ Attempting to create session...');
                try {
                    const sessionId = await secureClient.createSession(file);
                    console.log('‚úÖ Session created successfully:', sessionId);
                    currentSession = { sessionId };
                } catch (sessionError) {
                    console.error('‚ùå Session creation failed with error:', sessionError);
                    console.error('‚ùå Error details:', {
                        message: sessionError.message,
                        stack: sessionError.stack,
                        name: sessionError.name,
                        cause: sessionError.cause
                    });
                    throw sessionError;
                }

                showStatus('info', 'üîë Performing key exchange...');
                updateNetworkRequestCount();

                // Perform key exchange and initialize session
                console.log('üîë Attempting key exchange and session initialization...');
                try {
                    const sessionData = await secureClient.initializeSession(currentSession.sessionId);
                    console.log('‚úÖ Session initialized successfully:', sessionData);
                    currentSession.sessionInfo = sessionData;
                } catch (initError) {
                    console.error('‚ùå Session initialization failed:', initError);
                    console.error('‚ùå Init error details:', {
                        message: initError.message,
                        stack: initError.stack
                    });
                    throw initError;
                }

                // Display session information
                displaySessionInfo(currentSession.sessionInfo, true);

                // Create secure player with client
                const { bufferStrategy, prefetchStrategy } = getSelectedStrategies();
                securePlayer = new SecureAudioPlayer(secureClient);
                console.log('üéµ SecureAudioPlayer created successfully');

                // Note: Buffer strategies are handled by the client, not the player
                console.log('üìä Using strategies:', { bufferStrategy: bufferStrategy.constructor.name, prefetchStrategy: prefetchStrategy.constructor.name });

                setupSecStreamPlayer();
                player.classList.remove('hidden');

                showStatus('success', '‚úÖ SecStream session ready! Real secure streaming active.');
                console.log('üîí SecStream session setup complete:', currentSession.sessionInfo);

            } catch (error) {
                console.error('üí• SecStream upload process failed:', error);
                console.error('üí• Full error stack:', error.stack);

                // Check if it's a network-related error
                if (error.message?.includes('fetch')) {
                    console.error('üåê Network error detected - checking server connectivity...');
                    try {
                        const response = await fetch('http://localhost:3000/health');
                        console.log('üè• Server health check:', response.status, response.statusText);
                    } catch (healthError) {
                        console.error('üö® Server appears to be down:', healthError);
                    }
                }

                throw new Error(`SecStream session creation failed: ${error.message}`);
            }
        }

        async function handleWebAudioUpload(file) {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                // Simulate session info
                const sessionData = {
                    sessionId: `web-audio-${Date.now()}`,
                    format: 'Web Audio',
                    sampleRate: audioBuffer.sampleRate,
                    channels: audioBuffer.numberOfChannels,
                    duration: audioBuffer.duration,
                    totalSlices: Math.ceil(audioBuffer.duration / 5), // 5 second slices
                    sliceDuration: 5000,
                };

                currentSession = { sessionInfo: sessionData };
                currentAudio = audioBuffer;

                displaySessionInfo(sessionData, false);
                setupWebAudioPlayer();
                player.classList.remove('hidden');

                showStatus('success', '‚úÖ Web Audio loaded! (Fallback mode - no encryption)');

            } catch (error) {
                throw new Error(`Web Audio decoding failed: ${error.message}`);
            }
        }

        function displaySessionInfo(sessionData, isSecStream) {
            const items = [
                { label: 'Session ID', value: sessionData.sessionId || 'N/A' },
                { label: 'Format', value: sessionData.format || 'Unknown' },
                { label: 'Sample Rate', value: sessionData.sampleRate ? `${sessionData.sampleRate} Hz` : 'Unknown' },
                { label: 'Channels', value: sessionData.channels || 'Unknown' },
                { label: 'Duration', value: sessionData.duration ? formatTime(sessionData.duration) : 'Unknown' },
                { label: 'Total Slices', value: sessionData.totalSlices || 'Unknown' },
                { label: 'Encryption', value: isSecStream ? 'üîí AES-256-GCM' : '‚ùå None (Fallback)' },
                { label: 'Transport', value: isSecStream ? 'üåê HTTP/SecStream' : 'üíæ Memory (Local)' }
            ];

            sessionGrid.innerHTML = items.map(item => `
                <div class="info-item">
                    <div class="info-label">${item.label}</div>
                    <div class="info-value">${item.value}</div>
                </div>
            `).join('');

            // Update total slices display
            totalSlicesEl.textContent = sessionData.totalSlices || 0;

            sessionInfo.classList.remove('hidden');
        }

        function getSelectedStrategies() {
            const bufferStrategyName = document.getElementById('bufferStrategy').value;
            const prefetchStrategyName = document.getElementById('prefetchStrategy').value;

            let bufferStrategy, prefetchStrategy;

            if (isSecStreamAvailable) {
                switch (bufferStrategyName) {
                    case 'conservative':
                        bufferStrategy = new ConservativeBufferStrategy();
                        break;
                    case 'aggressive':
                        bufferStrategy = new AggressiveBufferStrategy();
                        break;
                    case 'balanced':
                    default:
                        bufferStrategy = new BalancedBufferStrategy();
                        break;
                }

                switch (prefetchStrategyName) {
                    case 'adaptive':
                        prefetchStrategy = new AdaptivePrefetchStrategy();
                        break;
                    case 'none':
                        prefetchStrategy = new NoPrefetchStrategy();
                        break;
                    case 'linear':
                    default:
                        prefetchStrategy = new LinearPrefetchStrategy();
                        break;
                }
            }

            // Update strategy display
            currentStrategyEl.textContent = `${bufferStrategyName}/${prefetchStrategyName}`;

            return { bufferStrategy, prefetchStrategy };
        }

        function updateStrategy() {
            if (secureClient && isSecStreamAvailable) {
                // Note: Buffer strategies are configured on the client, not the player
                // The strategies were already set when the client was created
                getSelectedStrategies(); // Update display
                showStatus('info', '‚öôÔ∏è Strategy selection updated (applied to client)');
            } else {
                getSelectedStrategies(); // Update display even in fallback mode
            }
        }

        function setupSecStreamPlayer() {
            if (!securePlayer) return;

            playBtn.classList.remove('playing');
            playBtn.onclick = toggleSecStreamPlay;

            // Set total time
            if (currentSession?.sessionInfo) {
                const duration = currentSession.sessionInfo.totalSlices * currentSession.sessionInfo.sliceDuration / 1000;
                totalTime.textContent = formatTime(duration);
            }

            // Set up player events
            securePlayer.addEventListener('play', () => {
                playBtn.classList.add('playing');
                isPlaying = true;
                startBufferStatsUpdates();
                showStatus('info', '‚ñ∂Ô∏è Playing encrypted stream...');
            });

            securePlayer.addEventListener('pause', () => {
                playBtn.classList.remove('playing');
                isPlaying = false;
                showStatus('info', '‚è∏Ô∏è Secure playback paused');
            });

            securePlayer.addEventListener('ended', () => {
                playBtn.classList.remove('playing');
                isPlaying = false;
                
                // Update progress bar to 100% completion before stopping updates
                progressFill.style.width = '100%';
                if (currentSession?.sessionInfo) {
                    const totalDuration = currentSession.sessionInfo.totalSlices * currentSession.sessionInfo.sliceDuration / 1000;
                    currentTime.textContent = formatTime(totalDuration);
                }
                
                stopBufferStatsUpdates();
                showStatus('success', 'üéµ Secure playback completed');
            });

            // Handle realtime timeupdate events (replaces setInterval)
            securePlayer.addEventListener('timeupdate', (e) => {
                const { currentTime: seconds, duration, progress } = e.detail;
                const percent = Math.min(progress * 100, 100);
                progressFill.style.width = `${percent}%`;
                currentTime.textContent = formatTime(seconds);

                // Prefetch upcoming slices for smooth playback
                const currentSlice = securePlayer.currentSlice;
                const sessionInfo = currentSession?.sessionInfo;
                if (sessionInfo && currentSlice < sessionInfo.totalSlices - 1) {
                    const nextSlice = currentSlice + 1;
                    const prefetchCount = Math.min(3, sessionInfo.totalSlices - nextSlice);
                    secureClient.prefetchSlices(nextSlice, prefetchCount).catch(err =>
                        console.warn('Prefetch error:', err)
                    );
                }
            });

            // Handle retry events for slice loading
            securePlayer.addEventListener('loadretry', (e) => {
                const { slice, attempt, maxRetries, error } = e.detail;
                showStatus('warning', `üîÑ Retrying slice ${slice} (${attempt}/${maxRetries}): ${error}`);
                console.log(`üîÑ SecStream: Retrying slice ${slice}, attempt ${attempt}/${maxRetries}`);
            });

            // Handle seek events
            securePlayer.addEventListener('seek', (e) => {
                const { time, slice, offset } = e.detail;
                console.log(`üéØ SecStream: Seeked to ${time.toFixed(2)}s (slice ${slice}, offset ${offset.toFixed(2)}s)`);
            });

            securePlayer.addEventListener('error', (event) => {
                const { message, retryable, time } = event.detail || {};
                if (retryable && time !== undefined) {
                    showStatus('error', `‚ùå ${message} - Click progress bar to retry from ${formatTime(time)}`);
                } else {
                    showStatus('error', `‚ùå Playback error: ${message || 'Unknown error'}`);
                }
                console.error('üö® SecStream error:', event.detail);
            });

            // Progress bar seeking
            progressBar.onclick = async (e) => {
                if (!securePlayer || !currentSession) return;

                const rect = progressBar.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const percent = clickX / rect.width;
                
                // Calculate target time in seconds for precise seeking
                const totalDuration = currentSession.sessionInfo.totalSlices * currentSession.sessionInfo.sliceDuration / 1000;
                const targetTime = percent * totalDuration;
                
                // Use the new time-based seeking with on-demand slice loading
                try {
                    showStatus('info', `‚è≠Ô∏è Seeking to ${formatTime(targetTime)}...`);
                    await securePlayer.seekToTime(targetTime, true); // true = auto-resume if was playing
                    showStatus('success', `‚úÖ Seeked to ${formatTime(targetTime)}`);
                } catch (seekError) {
                    console.error('‚ùå Seek failed:', seekError);
                    showStatus('error', `‚ùå Seek failed: ${seekError.message}`);
                }

                updateNetworkRequestCount(); // Seeking may trigger network requests
                showStatus('info', `‚è≠Ô∏è Seeking to slice ${targetSlice}`);
            };
        }

        function setupWebAudioPlayer() {
            if (!currentAudio) return;

            playBtn.classList.remove('playing');
            playBtn.onclick = toggleWebAudioPlay;
            totalTime.textContent = formatTime(currentAudio.duration);

            // Progress bar seeking
            progressBar.onclick = (e) => {
                if (!currentAudio) return;

                const rect = progressBar.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const percent = clickX / rect.width;
                const targetTime = percent * currentAudio.duration;

                // In real implementation, would seek to targetTime
                showStatus('info', `‚è≠Ô∏è Would seek to ${formatTime(targetTime)} (Web Audio fallback)`);
            };
        }

        async function toggleSecStreamPlay() {
            if (!securePlayer) return;

            try {
                if (securePlayer.isPlaying) {
                    securePlayer.pause(); // pause() is synchronous, no await needed
                } else {
                    // Preload initial slices before playing
                    const currentSlice = securePlayer.currentSlice;
                    showStatus('info', 'üì¶ Preloading audio slices for smooth playback...');

                    try {
                        await secureClient.prefetchSlices(currentSlice, 3);
                        console.log('‚úÖ Initial slices preloaded successfully');
                    } catch (prefetchError) {
                        console.warn('‚ö†Ô∏è Prefetch failed, playing anyway:', prefetchError);
                    }

                    await securePlayer.play();
                    updateNetworkRequestCount(); // Playing triggers network requests
                }
            } catch (error) {
                showStatus('error', `‚ùå Playback control error: ${error.message}`);
                console.error('Playback control error details:', error);
            }
        }

        async function toggleWebAudioPlay() {
            // Web Audio fallback implementation
            if (isPlaying) {
                playBtn.classList.remove('playing');
                isPlaying = false;
                stopProgressUpdates();
                showStatus('info', '‚è∏Ô∏è Web Audio playback paused (simulated)');
            } else {
                playBtn.classList.add('playing');
                isPlaying = true;
                startProgressUpdates();
                showStatus('info', '‚ñ∂Ô∏è Web Audio playback started (simulated)');
            }
        }

        function startProgressUpdates() {
            if (progressInterval) clearInterval(progressInterval);

            progressInterval = setInterval(() => {
                if (securePlayer && isSecStreamAvailable) {
                    // Get real progress from SecStream player using time-based calculation
                    const currentSeconds = securePlayer.currentTime;
                    const totalSlices = currentSession?.sessionInfo?.totalSlices || 1;
                    const totalDuration = totalSlices * (currentSession?.sessionInfo?.sliceDuration || 5000) / 1000;
                    
                    // Use time-based progress for more accurate representation
                    const percent = Math.min((currentSeconds / totalDuration) * 100, 100);

                    progressFill.style.width = `${percent}%`;
                    currentTime.textContent = formatTime(currentSeconds);

                    // Preload next slices for smooth network playback
                    const currentSlice = securePlayer.currentSlice;
                    if (currentSlice < totalSlices - 1) {
                        // Prefetch upcoming slices more aggressively
                        const nextSlice = currentSlice + 1;
                        const prefetchCount = Math.min(3, totalSlices - nextSlice);
                        secureClient.prefetchSlices(nextSlice, prefetchCount).catch(err =>
                            console.warn('Prefetch error:', err)
                        );
                    }
                } else if (currentAudio) {
                    // Simulate progress for Web Audio fallback
                    const currentSeconds = parseFloat(currentTime.textContent.split(':').reduce((acc, time) => (60 * acc) + +time, 0));
                    const newSeconds = Math.min(currentSeconds + 0.1, currentAudio.duration);
                    const percent = (newSeconds / currentAudio.duration) * 100;

                    progressFill.style.width = `${percent}%`;
                    currentTime.textContent = formatTime(newSeconds);

                    if (newSeconds >= currentAudio.duration) {
                        toggleWebAudioPlay();
                        showStatus('success', 'üéµ Web Audio playback completed (simulated)');
                    }
                }
            }, 100);
        }

        function stopProgressUpdates() {
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
        }

        function startBufferStatsUpdates() {
            if (bufferStatsInterval) clearInterval(bufferStatsInterval);

            if (securePlayer && isSecStreamAvailable) {
                bufferStatsInterval = setInterval(() => {
                    try {
                        const stats = securePlayer.getBufferStats();
                        bufferSizeEl.textContent = stats.bufferSize || 0;

                        // Update network request count based on real activity
                        if (stats.newRequests) {
                            networkRequestCount += stats.newRequests;
                            networkRequestsEl.textContent = networkRequestCount;
                        }
                    } catch (error) {
                        console.warn('Error getting buffer stats:', error);
                    }
                }, 1000);
            }
        }

        function stopBufferStatsUpdates() {
            if (bufferStatsInterval) {
                clearInterval(bufferStatsInterval);
                bufferStatsInterval = null;
            }
        }

        // Initialize the application
        console.log('üöÄ SecStream Demo initialized');

        if (isSecStreamAvailable) {
            console.log('üîí Real SecStream functionality available');
        } else {
            console.log('üí° Running in Web Audio fallback mode');
        }
    </script>
</body>

</html>